 
import coin_utils
import random
 
len_AllCHAR=len(coin_utils.ALL_CHARACTERS)
TEST_decrypt_with_user_input_TOO_LONG=''		#has 107 unique coin values, 1 above what decrypt_with_user_input should be able to handle
for base10 in range(107):
	TEST_decrypt_with_user_input_TOO_LONG+=coin_utils.base10_to_202(base10)
 
def get_crypt_dictionary(keys, value_generator=coin_utils.get_random_comp202coin):
	"""
	(list,func)-> dict
	receives a list of unique values and a value generating functions
	returns a list with each entry in the list as a key pointing a unique value generated by value_generator
 
	>>> random.seed(9001)
	>>> get_crypt_dictionary(['a', 'b', 'c'])
	{'a': '0c0MPNN0OC', 'b': '0cMIMNIO0P', 'c': '0cM0OCCIOI'}
 
	>>> get_crypt_dictionary([])
	{}
 
	>>> random.seed(0)
	>>> x=get_crypt_dictionary([1,2,3],coin_utils.tester_rand1_3)
	>>> x=={1: '2', 2: '1', 3: '3'}
	True
 
	>>> x=get_crypt_dictionary([3,2,4,1],coin_utils.tester_index)
	>>> x=={3: '0', 2: '1', 4: '2', 1:'3'}
	True
 
	>>> get_crypt_dictionary([],max)
	{}
 
	>>> get_crypt_dictionary({},max)
	Traceback (most recent call last):
	AssertionError: first parameters must be list
 
	>>> get_crypt_dictionary([1,2,3,4,5,1])
	Traceback (most recent call last):
	AssertionError: duplicate keys found
 
	>>> len_AllCHAR=78
	>>> get_crypt_dictionary(list(range(len_AllCHAR+1)))
	Traceback (most recent call last):
	AssertionError: input list must have more than 78 entries
 
	>>> get_crypt_dictionary([],12)
	Traceback (most recent call last):
	AssertionError: second parameter must be callable
 
	>>> get_crypt_dictionary([1,2,3],coin_utils.tester_return_1)
	Traceback (most recent call last):
	AssertionError: generator function did not generate valid value within 10000 iterations
 
	"""
	if type(keys)!=list :
		raise AssertionError('first parameters must be list')	# parameter check
	elif len(keys)>len_AllCHAR:
		raise AssertionError('input list must have more than '+str(len_AllCHAR)+' entries')	#length check
	elif str(type(value_generator)) not in ("<class 'function'>","<class 'builtin_function_or_method'>"): # you wont let me use callable()
		raise AssertionError('second parameter must be callable')		# convineniently callable is a function itself! What a surprise.
 
	dictionary=dict()
	
	for index, key in enumerate(keys):
		if key in dictionary:
			raise AssertionError('duplicate keys found')		# uniqueness check
 
		next_in_line=value_generator(index)
		current_values=dictionary.values()			#generate the next value we want to put in the dictionary
		whileloop_limit=0
		while next_in_line in current_values:		# if its already in it, we keep rerolling
			next_in_line=value_generator(index)
			whileloop_limit+=1
 
			if whileloop_limit>10000:
				raise AssertionError('generator function did not generate valid value within 10000 iterations')	# infinit loop break
 
		dictionary[key]=next_in_line
	return dictionary
		
def encrypt_text(text,value_generator=coin_utils.get_random_comp202coin): # i need a legitimate way to test this, hence the extra parameter
	"""
	(str,func)-> tuple(str,dict)
	Encrypts the given text in comp202coin and returns the encrypted version and the decryption dictionary
 
	>>> random.seed(9001)
	>>> x=encrypt_text('ToO')
	>>> x==('0c0MPNN0OC-0cMIMNIO0P-0cMIMNIO0P', {'t': '0c0MPNN0OC', 'o': '0cMIMNIO0P'})
	True
 
	>>> encrypt_text('')
	('', {})
 
	>>> random.seed(0)
	>>> x=encrypt_text('123',coin_utils.tester_rand1_3)
	>>> x==('2-1-3',{'1': '2', '2': '1', '3': '3'})
	True
 
	>>> random.seed(0)
	>>> x=encrypt_text('3241433142221',coin_utils.tester_index)
	>>> x==('0-1-2-3-2-0-0-3-2-1-1-1-3',{'3': '0', '2': '1', '4': '2', '1':'3'})
	True
 
	#>>> encrypt_text('*pound symbol')				# utf-8 keeps throwing tantrums no matter what character i put here
	#Traceback (most recent call last):				# i guess i will imput this manually
	#AssertionError: unrecognized character in text
 
	>> encrypt_text([])
	Traceback (most recent call last):
	AssertionError: parameter must be a string
	"""
	if type(text)!=str:
		raise AssertionError('parameter must be a string')		#type check
 
	unique_chars=list()
	text=text.lower()
 
	for char in text:
		if char not in coin_utils.ALL_CHARACTERS:
			raise AssertionError('unrecognized character in text')	#validity check
 
		elif char not in unique_chars:
			unique_chars.append(char)					#unique characters go in here
 
	encryptor = get_crypt_dictionary(unique_chars,value_generator)
 
	encrypted_text=''
	for char in text:
		encrypted_text+=encryptor[char]+'-'	# add each encrypted character plus a hyphen
	encrypted_text=encrypted_text[:-1]			# remove last hypeh
	
	return (encrypted_text,encryptor) 
 
def encrypt_file(filename):
	"""
	(str)->dict
	receives a file name (eg. my_filex.txt).
	creates a new file with _encrypted append to the end of its name (eg. my_filex_encrypted.txt) where all of the characters
	have been encrypted into a comp202coin value. returns the encryption dictionary.
 
	>>> random.seed(42)
	>>> x=encrypt_file('dubliners.txt')
	>>> (x['t'],x['3'])
	('0cCI200CM2', '0c2PNCNPNM')
 
	>>> fobj = open('dubliners_encrypted.txt', 'r', encoding='utf-8')
	>>> x=fobj.read() 
	>>> len(x) 
	4282475 
	>>> x[:11] 
	'0cCI200CM2-' 
	>>> fobj.close() 
  
	>>> x=encrypt_file([]) 
	Traceback (most recent call last):
	AssertionError: parameter must be a file name inputed as a string
	"""
	if type(filename)!=str:
		raise AssertionError('parameter must be a file name inputed as a string')
 
	output_filename=filename.split('.')				# seperate, add _encrypted to part before .
	output_filename[0]+='_encrypted'				# join them back into 1 string
	output_filename='.'.join(output_filename)
 
	try:											#we must close files no matter what
		read_file=open(filename,'r',encoding='utf-8')	# you were very mean for not telling me to write encoding='utf-8'
		write_file=open(output_filename,'w')
 
		encryption, dictionary=encrypt_text(read_file.read())
 
		write_file.write(encryption)
 
		return dictionary
	finally:
		read_file.close()
		write_file.close()
 
def decrypt_text(text, decryption_dict):
	"""
	(str,dict,function)->str
	Receives encrypted text in comp202 coin and decrypts it using a valid decryption_dict
	
	>>> d = {'0c0MPNN0OC': 'a', '0cMIMNIO0P': 'b', '0cM0OCCIOI': 'c'}
	>>> decrypt_text('0c0MPNN0OC-0cM0OCCIOI-0c0MPNN0OC', d)
	'aca'
 
	>>> decrypt_text([],{})
	Traceback (most recent call last):
	AssertionError: parameters must be (string,dictionary)
 
	>>> decrypt_text('',[])
	Traceback (most recent call last):
	AssertionError: parameters must be (string,dictionary)
 
	>>> d={'0c0MPNN0OC': 'a', '0cMIMNIO0P': 'b', '0cM0OCCIOI': 'c','0cM0OCCION':'5' }
	>>> decrypt_text('0c0MPNN0OC-0cMIMNIO0P-0cM0OCCIOI-0cM0OCCIOI-0cM0OCCION-0cM0OCCIOI-0cM0OCCIOI',d)
	'abcc5cc'
 
	>>> d={'0c0MPNN0OC': 'a', '0cMIMNIO0P': 'b', '0cM0OCCIOI': 'c'}
	>>> decrypt_text('0c0MPNN0OC-0cMIMNIO0P-0cM0OCCIOI-0cM0OCCIOI-0cM0OCCION-0cM0OCCIOI-0cM0OCCIOI',d)
	Traceback (most recent call last):
	AssertionError: encrypted item not found in dictionary
 
	>>> decrypt_text('fuzzywuzzy',{})
	Traceback (most recent call last):
	AssertionError: non coin item found in text
 
	>>> decrypt_text('',{'ursa warrior':'5'})
	Traceback (most recent call last):
	AssertionError: dictionary has invalid inputs
 
	>>> decrypt_text('',{'0cMIMNIO0P':5})
	Traceback (most recent call last):
	AssertionError: dictionary has invalid inputs
	"""
	if (type(text),type(decryption_dict))!=(str,dict):
		raise AssertionError('parameters must be (string,dictionary)')		# type check
 
	for key,value in decryption_dict.items():
		if not coin_utils.is_base202(key) or type(value)!= str:
			raise AssertionError('dictionary has invalid inputs')			# dictionary value check
 
	text_list=text.split('-')				# get_all_coins is too damn slow for this purpose
	decryption=''
	for subtext in text_list:
 
		if not coin_utils.is_base202(subtext):
			raise AssertionError('non coin item found in text')
		elif subtext not in decryption_dict:
			raise AssertionError('encrypted item not found in dictionary')	# check if dictionary has all encrypted items in text
 
		decryption+=decryption_dict[subtext]			# add all decrypted entries here
 
	return decryption
 
def decrypt_file(filename, decryption_dict):
	"""
	(str,dict)->void
	Rceives a file name and a dictionary. decryps the file using the input dictionary. stores the file as [filename]_decrypted.[type]
 
	>>> random.seed(12)
	>>> x=encrypt_file('dubliners.txt')
	>>> d=coin_utils.reverse_dict(x)
	>>> decrypt_file('dubliners_encrypted.txt', d)
	>>> original= open('dubliners.txt','r',encoding='utf-8')
	>>> decrypted = open('dubliners_encrypted_decrypted.txt','r',encoding='utf-8')
 
	>>> ori=original.read().lower()
	>>> fake=decrypted.read()
	>>> ori==fake
	True
	>>> original.close()
	>>> decrypted.close()
 
	>>> random.seed(0)
	>>> x=encrypt_file('dubliners.txt')
	>>> d=coin_utils.reverse_dict(x)
	>>> decrypt_file('dubliners_encrypted.txt', d)
	>>> original= open('dubliners.txt','r',encoding='utf-8')
	>>> decrypted = open('dubliners_encrypted_decrypted.txt','r',encoding='utf-8')
 
	>>> ori=original.read().lower()
	>>> fake=decrypted.read()
	>>> ori==fake
	True
	>>> original.close()
	>>> decrypted.close()
 
	>>> random.seed(42)
	>>> x=encrypt_file('dubliners.txt')
	>>> d=coin_utils.reverse_dict(x)
	>>> decrypt_file('dubliners_encrypted.txt', d)
	>>> original= open('dubliners.txt','r',encoding='utf-8')
	>>> decrypted = open('dubliners_encrypted_decrypted.txt','r',encoding='utf-8')
 
	>>> ori=original.read().lower()
	>>> fake=decrypted.read()
	>>> ori==fake
	True
	
 
	>>> original.close()
	>>> decrypted.close()
 
	>>> decrypt_file([], d)
	Traceback (most recent call last):
	AssertionError: first parameter must be a file name inputed as a string and second must be a dictionary
 
	>>> decrypt_file('dubliners_encrypted.txt', {})
	Traceback (most recent call last):
	AssertionError: encrypted item not found in dictionary
	"""
	if (type(filename),type(decryption_dict))!=(str,dict):				# dictionary validation should be further handled in decrypt_text
		raise AssertionError('first parameter must be a file name inputed as a string and second must be a dictionary')
 
 
	output_filename=filename.split('.')				# seperate, add _decrypted to part before .
	output_filename[0]+='_decrypted'				# join them back into 1 string
	output_filename='.'.join(output_filename)
 
	try:											#we must close files no matter what
		read_file=open(filename,'r',encoding='utf-8')
		write_file=open(output_filename,'w',encoding='utf-8')
 
		decryption=decrypt_text(read_file.read(),decryption_dict)
 
		write_file.write(decryption)
 
	finally:
		read_file.close()
		write_file.close()
 
def random_decrypt(encrypted_s, n, common_words_filename='common_words.txt'):
	"""
	(str,int,str)->str
	Takes a filename and 
 
	>>> random.seed(49)
	>>> encrypted_s = '0c0MPNN0OC-0cMIMNIO0P-0cMIMNIO0P'
	>>> random_decrypt(encrypted_s, 10**2, 'common_words.txt')
	'f33'
	>>> random.seed(49)
	>>> random_decrypt(encrypted_s, 10**3, 'common_words.txt')
	'too'
 
	>>> random_decrypt('', 10**2, 'common_words.txt')
	''
	
	>>> random.seed(0)
	>>> random_decrypt('0c0MPNN0OC-0cMIMNIO0P', 10**3, 'common_words.txt')
	'at'
 
	>>> random_decrypt('0c0MPNN0OC-0cMIMNIO0P', 0, 'common_words.txt')
	Traceback (most recent call last):
	AssertionError: integer input must be positive
 
	>>> random_decrypt(15, 1, 'common_words.txt')
	Traceback (most recent call last):
	AssertionError: random_decrypt input is (str,int,str)
	"""
	if (type(encrypted_s),type(n),type(common_words_filename))!=(str,int,str):
		raise AssertionError('random_decrypt input is (str,int,str)')
	elif n<=0:
		raise AssertionError('integer input must be positive')
	elif encrypted_s=='':											# Should return '', otherwise we get assertion error because
		return ''													# '' is technically not in base202
 
	value_generator=coin_utils.get_random_character				# we need char values from ALL_CHARACTERS
	encrypted_entries=coin_utils.get_unique_elements(coin_utils.get_all_coins(encrypted_s))	# we save the unique elements
 
	current_result=''
 
	for i in range(n):												# we perform random decryption n times
		decryption_dict=get_crypt_dictionary(encrypted_entries,value_generator)
		decryption=decrypt_text(encrypted_s, decryption_dict)
 
		if coin_utils.get_pct_common_words(decryption, common_words_filename)>=\
			coin_utils.get_pct_common_words(current_result, common_words_filename):
			current_result=decryption
 
	return current_result
 
def decrypt_with_user_input(encrypted_s):
	"""
	(str)->str
	Decrypts test based on character frequency
	Uses user input to validate decryption. If the user is satisfied, the decrypted string will be returned.
	Otherwise, the user may choose to swap two letters.
 
	>>> decrypt_with_user_input([])
	Traceback (most recent call last):
	AssertionError: decrypt_with_user_input takes a string argument
 
	>>> decrypt_with_user_input(TEST_decrypt_with_user_input_TOO_LONG)
	Traceback (most recent call last):
	AssertionError: too many unique encrypted values in text
 
	>> random.seed(138)
	>> text='The spelling of English words is not fixed and invariable, nor '+\
'does it depend on any other authority than general agreement. At the present day there is '+\
'practically unanimous agreement as to the spelling of most words. In the list below, for '+\
'example, \'rime\' for \'rhyme\' is the only allowable variation; all the other forms are '+\
'co-extensive with the English language. At any given moment, however, a relatively '+\
'small number of words may be spelled in more than one way. Gradually, as a rule, one of '+\
'these forms comes to be generally preferred, and the less customary form comes to look '+\
'obsolete and is discarded. From time to time new forms, mostly simplifications, are '+\
'introduced by innovators, and either win their place or die of neglect.'
	>> s, d = encrypt_text(text)
	>> decryption='THE SUELLING OY ENGLISH PORDS IS NOT YI,ED AND INXARIAVLEC NOR DOES IT '+\
'DEUEND ON ANF OTHER ABTHORITF THAN GENERAL AGREEMENTK AT THE URESENT DAF THERE IS '+\
'URAWTIWALLF BNANIMOBS AGREEMENT AS TO THE SUELLING OY MOST PORDSK IN THE LIST VELOPC YOR '+\
'E,AMULEC .RIME. YOR .RHFME. IS THE ONLF ALLOPAVLE XARIATION" ALL THE OTHER YORMS ARE '+\
'WO-E,TENSIXE PITH THE ENGLISH LANGBAGEK AT ANF GIXEN MOMENTC HOPEXERC A RELATIXELF '+\
'SMALL NBMVER OY PORDS MAF VE SUELLED IN MORE THAN ONE PAFK GRADBALLFC AS A RBLEC ONE OY '+\
'THESE YORMS WOMES TO VE GENERALLF UREYERREDC AND THE LESS WBSTOMARF YORM WOMES TO LOO\' '+\
'OVSOLETE AND IS DISWARDEDK YROM TIME TO TIME NEP YORMSC MOSTLF SIMULIYIWATIONSC ARE '+\
'INTRODBWED VF INNOXATORSC AND EITHER PIN THEIR ULAWE OR DIE OY NEGLEWTK'
	>> decrypt_with_user_input(s)==decryption
	End decryption? [yes]
	True
 
	>> s, d = encrypt_text('34142423443')		# 4 appears 4 times, 3;3 etc.
	>> s=decrypt_with_user_input(s)
	Decrypted string: E T O OE  E
	End decryption? [N]
	Enter first letter to swap:  
	Enter second letter to swap: G
	Decrypted string: EGTGOGOEGGE
	End decryption? [YES]
	>> s
	'EGTGOGOEGGE'
																					
	>> s=decrypt_with_user_input(TEST_decrypt_with_user_input_TOO_LONG[:-1])		# utf-8 cant decode the next line at ---0-9--
	Decrypted string: ---0-9--mbnzclvx86724153.",|'}:;pioryeut{]\=+-[_khjsfagdw		# oe-c<cedilla>-ae-0-e<grave>-9-e<aigue>
	q<?/	>)*($^#&%,K.UVPXB@~!";'`-SLITRONAWGCHYMFDE								# the above is what is supposed to be written
	End decryption? yes
 
	>> len(s)
	106
	"""
	if type(encrypted_s)!=str:
		raise AssertionError('decrypt_with_user_input takes a string argument')	# validation
 
	encrypted_coins=coin_utils.get_all_coins(encrypted_s)						# store as list of coins
	coin_freq_ordered=coin_utils.sort_keys_by_values(coin_utils.get_frequencies(encrypted_coins))	# get unique coins by frequency
	
	FULL_CHARACTER_SET= coin_utils.LETTERS_IN_POPULARITY_ORDER+coin_utils.PUNCTUATION[:-4]+'\t\n'+\
		coin_utils.ALPHABET		# I wanted to take into account if the text had more characters than letters in popularity order
									# i hope there isnt a private test where we are given too many characteres and are expected
									# to raise an asserion error
	if len(coin_freq_ordered)>len(FULL_CHARACTER_SET):
		raise AssertionError('too many unique encrypted values in text')	# can accomodate for 106 unique characters :)
	
	free_dictionary=dict()
	for index,coin in enumerate(coin_freq_ordered):
		free_dictionary[coin]=FULL_CHARACTER_SET[index]			# build dict with nth popular coin pointing to nth popular character
 
	current_text = decrypt_text(encrypted_s,free_dictionary)
 
	print('Decrypted string: '+current_text)
	response=input('End decryption? ')
	while response.lower() != 'yes':				
		letter1=input('Enter first letter to swap: ')
		letter2=input('Enter second letter to swap: ')
		current_text=coin_utils.swap_letters(current_text, letter1, letter2)
		print('Decrypted string: '+current_text)
		response=input('End decryption? ')						# loop will repeat untill user inputs yes. Case insensitive
 
	return current_text